# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T01:57:40+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Path, Query, Request

from models import (
    ActivateManualTriggerRequest,
    Advertiser,
    Alt,
    AssignedInventorySource,
    AssignedLocation,
    AssignedTargetingOption,
    AuditAdvertiserResponse,
    BulkEditAdvertiserAssignedTargetingOptionsRequest,
    BulkEditAdvertiserAssignedTargetingOptionsResponse,
    BulkEditAssignedInventorySourcesRequest,
    BulkEditAssignedInventorySourcesResponse,
    BulkEditAssignedLocationsRequest,
    BulkEditAssignedLocationsResponse,
    BulkEditAssignedTargetingOptionsRequest,
    BulkEditAssignedTargetingOptionsResponse,
    BulkEditAssignedUserRolesRequest,
    BulkEditAssignedUserRolesResponse,
    BulkEditNegativeKeywordsRequest,
    BulkEditNegativeKeywordsResponse,
    BulkEditPartnerAssignedTargetingOptionsRequest,
    BulkEditPartnerAssignedTargetingOptionsResponse,
    BulkEditSitesRequest,
    BulkEditSitesResponse,
    BulkListAdGroupAssignedTargetingOptionsResponse,
    BulkListAdvertiserAssignedTargetingOptionsResponse,
    BulkListAssignedTargetingOptionsResponse,
    BulkListCampaignAssignedTargetingOptionsResponse,
    BulkListInsertionOrderAssignedTargetingOptionsResponse,
    BulkUpdateLineItemsRequest,
    BulkUpdateLineItemsResponse,
    Campaign,
    Channel,
    CombinedAudience,
    CreateAssetResponse,
    CreateSdfDownloadTaskRequest,
    Creative,
    CustomBiddingAlgorithm,
    CustomBiddingScript,
    CustomBiddingScriptRef,
    CustomList,
    DeactivateManualTriggerRequest,
    DuplicateLineItemRequest,
    DuplicateLineItemResponse,
    EditCustomerMatchMembersRequest,
    EditCustomerMatchMembersResponse,
    EditGuaranteedOrderReadAccessorsRequest,
    EditGuaranteedOrderReadAccessorsResponse,
    EditInventorySourceReadWriteAccessorsRequest,
    Empty,
    FieldXgafv,
    FirstAndThirdPartyAudience,
    FloodlightGroup,
    GenerateDefaultLineItemRequest,
    GoogleAudience,
    GoogleBytestreamMedia,
    GuaranteedOrder,
    InsertionOrder,
    InventorySource,
    InventorySourceAccessors,
    InventorySourceGroup,
    LineItem,
    LineItemIds,
    ListAdvertiserAssignedTargetingOptionsResponse,
    ListAdvertisersResponse,
    ListAssignedInventorySourcesResponse,
    ListAssignedLocationsResponse,
    ListCampaignAssignedTargetingOptionsResponse,
    ListCampaignsResponse,
    ListChannelsResponse,
    ListCombinedAudiencesResponse,
    ListCreativesResponse,
    ListCustomBiddingAlgorithmsResponse,
    ListCustomBiddingScriptsResponse,
    ListCustomListsResponse,
    ListFirstAndThirdPartyAudiencesResponse,
    ListGoogleAudiencesResponse,
    ListGuaranteedOrdersResponse,
    ListInsertionOrderAssignedTargetingOptionsResponse,
    ListInsertionOrdersResponse,
    ListInventorySourceGroupsResponse,
    ListInventorySourcesResponse,
    ListInvoicesResponse,
    ListLineItemAssignedTargetingOptionsResponse,
    ListLineItemsResponse,
    ListLocationListsResponse,
    ListManualTriggersResponse,
    ListNegativeKeywordListsResponse,
    ListNegativeKeywordsResponse,
    ListPartnerAssignedTargetingOptionsResponse,
    ListPartnersResponse,
    ListSitesResponse,
    ListTargetingOptionsResponse,
    ListUsersResponse,
    ListYoutubeAdGroupAdsResponse,
    ListYoutubeAdGroupAssignedTargetingOptionsResponse,
    ListYoutubeAdGroupsResponse,
    LocationList,
    LoiSapinInvoiceType,
    LookupInvoiceCurrencyResponse,
    ManualTrigger,
    NegativeKeywordList,
    Operation,
    Partner,
    ReplaceNegativeKeywordsRequest,
    ReplaceNegativeKeywordsResponse,
    ReplaceSitesRequest,
    ReplaceSitesResponse,
    SearchTargetingOptionsRequest,
    SearchTargetingOptionsResponse,
    TargetingOption,
    TargetingType,
    User,
    YoutubeAdGroup,
    YoutubeAdGroupAd,
    YoutubeAdGroupIds,
)

app = MCPProxy(
    contact={'name': 'Google', 'url': 'https://google.com', 'x-twitter': 'youtube'},
    description='Display & Video 360 API allows users to automate complex Display & Video 360 workflows, such as creating insertion orders and setting targeting options for individual line items.',
    license={
        'name': 'Creative Commons Attribution 3.0',
        'url': 'http://creativecommons.org/licenses/by/3.0/',
    },
    termsOfService='https://developers.google.com/terms/',
    title='Display & Video 360 API',
    version='v2',
    servers=[{'url': 'https://displayvideo.googleapis.com/'}],
)


@app.get(
    '/download/{resourceName}',
    description=""" Downloads media. Download is supported on the URI `/download/{resource_name=**}?alt=media.` **Note**: Download requests will not be successful without including `alt=media` query string. """,
    tags=['media_operations', 'video_download_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_media_download(
    resource_name: str = Path(..., alias='resourceName'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/media/{resourceName}',
    description=""" Uploads media. Upload is supported on the URI `/upload/media/{resource_name=**}?upload_type=media.` **Note**: Upload requests will not be successful without including `upload_type=media` query string. """,
    tags=['advertiser_management', 'campaign_management', 'creative_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_media_upload(
    resource_name: str = Path(..., alias='resourceName'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers',
    description=""" Lists advertisers that are accessible to the current user. The order is defined by the order_by parameter. A single partner_id is required. Cross-partner listing is not supported. """,
    tags=['partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_list(
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers',
    description=""" Creates a new advertiser. Returns the newly created advertiser if successful. This method can take up to 180 seconds to complete. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_create(
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Advertiser = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}',
    description=""" Deletes an advertiser. Deleting an advertiser will delete all of its child resources, for example, campaigns, insertion orders and line items. A deleted advertiser cannot be recovered. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_delete(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}',
    description=""" Gets an advertiser. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_get(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/advertisers/{advertiserId}',
    description=""" Updates an existing advertiser. Returns the updated advertiser if successful. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_patch(
    advertiser_id: str = Path(..., alias='advertiserId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Advertiser = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/assets',
    description=""" Uploads an asset. Returns the ID of the newly uploaded asset if successful. The asset file size should be no more than 10 MB for images, 200 MB for ZIP files, and 1 GB for videos. Must be used within the [multipart media upload process](/display-video/api/guides/how-tos/upload#multipart). Examples using provided client libraries can be found in our [Creating Creatives guide](/display-video/api/guides/creating-creatives/overview#upload_an_asset). """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_assets_upload(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/campaigns',
    description=""" Lists campaigns in an advertiser. The order is defined by the order_by parameter. If a filter by entity_status is not specified, campaigns with `ENTITY_STATUS_ARCHIVED` will not be included in the results. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_campaigns_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/campaigns',
    description=""" Creates a new campaign. Returns the newly created campaign if successful. """,
    tags=['advertiser_management', 'campaign_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_campaigns_create(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Campaign = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}/campaigns/{campaignId}',
    description=""" Permanently deletes a campaign. A deleted campaign cannot be recovered. The campaign should be archived first, i.e. set entity_status to `ENTITY_STATUS_ARCHIVED`, to be able to delete it. """,
    tags=['advertiser_management', 'campaign_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_campaigns_delete(
    advertiser_id: str = Path(..., alias='advertiserId'),
    campaign_id: str = Path(..., alias='campaignId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/campaigns/{campaignId}',
    description=""" Gets a campaign. """,
    tags=['advertiser_management', 'campaign_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_campaigns_get(
    advertiser_id: str = Path(..., alias='advertiserId'),
    campaign_id: str = Path(..., alias='campaignId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/advertisers/{advertiserId}/campaigns/{campaignId}',
    description=""" Updates an existing campaign. Returns the updated campaign if successful. """,
    tags=['advertiser_management', 'campaign_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_campaigns_patch(
    advertiser_id: str = Path(..., alias='advertiserId'),
    campaign_id: str = Path(..., alias='campaignId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Campaign = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/campaigns/{campaignId}/targetingTypes/{targetingType}/assignedTargetingOptions',
    description=""" Lists the targeting options assigned to a campaign for a specified targeting type. """,
    tags=[
        'advertiser_management',
        'campaign_management',
        'targeting_options_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_advertiser_campaign_targeting_options_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    campaign_id: str = Path(..., alias='campaignId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/campaigns/{campaignId}/targetingTypes/{targetingType}/assignedTargetingOptions/{assignedTargetingOptionId}',
    description=""" Gets a single targeting option assigned to a campaign. """,
    tags=[
        'advertiser_management',
        'campaign_management',
        'targeting_options_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_assigned_targeting_options_for_campaign(
    advertiser_id: str = Path(..., alias='advertiserId'),
    campaign_id: str = Path(..., alias='campaignId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    assigned_targeting_option_id: str = Path(..., alias='assignedTargetingOptionId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/campaigns/{campaignId}:listAssignedTargetingOptions',
    description=""" Lists assigned targeting options of a campaign across targeting types. """,
    tags=['advertiser_management', 'campaign_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_campaign_targeting_options(
    advertiser_id: str = Path(..., alias='advertiserId'),
    campaign_id: str = Path(..., alias='campaignId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/channels',
    description=""" Lists channels for a partner or advertiser. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_channels_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/channels',
    description=""" Creates a new channel. Returns the newly created channel if successful. """,
    tags=['advertiser_management', 'channel_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_channels_create(
    advertiser_id: str = Path(..., alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/advertisers/{advertiserId}/channels/{channelId}',
    description=""" Updates a channel. Returns the updated channel if successful. """,
    tags=['channel_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_channels_patch(
    advertiser_id: str = Path(..., alias='advertiserId'),
    channel_id: str = Path(..., alias='channelId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/channels/{channelId}/sites',
    description=""" Lists sites in a channel. """,
    tags=['advertiser_management', 'channel_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_channels_sites_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    channel_id: str = Path(..., alias='channelId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}/channels/{channelId}/sites/{urlOrAppId}',
    description=""" Deletes a site from a channel. """,
    tags=['advertiser_management', 'channel_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_channels_sites_delete(
    advertiser_id: str = Path(..., alias='advertiserId'),
    channel_id: str = Path(..., alias='channelId'),
    url_or_app_id: str = Path(..., alias='urlOrAppId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/channels/{channelId}/sites:bulkEdit',
    description=""" Bulk edits sites under a single channel. The operation will delete the sites provided in BulkEditSitesRequest.deleted_sites and then create the sites provided in BulkEditSitesRequest.created_sites. """,
    tags=['advertiser_management', 'channel_management', 'bulk_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_channels_sites_bulk_edit(
    advertiser_id: str = Path(..., alias='advertiserId'),
    channel_id: str = Path(..., alias='channelId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: BulkEditSitesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/channels/{channelId}/sites:replace',
    description=""" Replaces all of the sites under a single channel. The operation will replace the sites under a channel with the sites provided in ReplaceSitesRequest.new_sites. """,
    tags=['advertiser_management', 'channel_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_channels_sites_replace(
    advertiser_id: str = Path(..., alias='advertiserId'),
    channel_id: str = Path(..., alias='channelId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ReplaceSitesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/creatives',
    description=""" Lists creatives in an advertiser. The order is defined by the order_by parameter. If a filter by entity_status is not specified, creatives with `ENTITY_STATUS_ARCHIVED` will not be included in the results. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_creatives_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/creatives',
    description=""" Creates a new creative. Returns the newly created creative if successful. """,
    tags=['advertiser_management', 'creative_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_creatives_create(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Creative = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}/creatives/{creativeId}',
    description=""" Deletes a creative. Returns error code `NOT_FOUND` if the creative does not exist. The creative should be archived first, i.e. set entity_status to `ENTITY_STATUS_ARCHIVED`, before it can be deleted. """,
    tags=['advertiser_management', 'creative_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_creatives_delete(
    advertiser_id: str = Path(..., alias='advertiserId'),
    creative_id: str = Path(..., alias='creativeId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/creatives/{creativeId}',
    description=""" Gets a creative. """,
    tags=['advertiser_management', 'creative_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_creatives_get(
    advertiser_id: str = Path(..., alias='advertiserId'),
    creative_id: str = Path(..., alias='creativeId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/advertisers/{advertiserId}/creatives/{creativeId}',
    description=""" Updates an existing creative. Returns the updated creative if successful. """,
    tags=['advertiser_management', 'creative_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_creatives_patch(
    advertiser_id: str = Path(..., alias='advertiserId'),
    creative_id: str = Path(..., alias='creativeId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Creative = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/insertionOrders',
    description=""" Lists insertion orders in an advertiser. The order is defined by the order_by parameter. If a filter by entity_status is not specified, insertion orders with `ENTITY_STATUS_ARCHIVED` will not be included in the results. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_insertion_orders_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/insertionOrders',
    description=""" Creates a new insertion order. Returns the newly created insertion order if successful. """,
    tags=['insertion_order_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_insertion_orders_create(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: InsertionOrder = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}/insertionOrders/{insertionOrderId}',
    description=""" Deletes an insertion order. Returns error code `NOT_FOUND` if the insertion order does not exist. The insertion order should be archived first, i.e. set entity_status to `ENTITY_STATUS_ARCHIVED`, to be able to delete it. """,
    tags=['advertiser_management', 'insertion_order_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_insertion_orders_delete(
    advertiser_id: str = Path(..., alias='advertiserId'),
    insertion_order_id: str = Path(..., alias='insertionOrderId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/insertionOrders/{insertionOrderId}',
    description=""" Gets an insertion order. Returns error code `NOT_FOUND` if the insertion order does not exist. """,
    tags=['advertiser_management', 'insertion_order_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_insertion_orders_get(
    advertiser_id: str = Path(..., alias='advertiserId'),
    insertion_order_id: str = Path(..., alias='insertionOrderId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/advertisers/{advertiserId}/insertionOrders/{insertionOrderId}',
    description=""" Updates an existing insertion order. Returns the updated insertion order if successful. """,
    tags=['insertion_order_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_insertion_orders_patch(
    advertiser_id: str = Path(..., alias='advertiserId'),
    insertion_order_id: str = Path(..., alias='insertionOrderId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: InsertionOrder = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/insertionOrders/{insertionOrderId}/targetingTypes/{targetingType}/assignedTargetingOptions',
    description=""" Lists the targeting options assigned to an insertion order. """,
    tags=[
        'advertiser_management',
        'insertion_order_management',
        'targeting_options_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def display_advertiser_insertion_order_targeting_options(
    advertiser_id: str = Path(..., alias='advertiserId'),
    insertion_order_id: str = Path(..., alias='insertionOrderId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/insertionOrders/{insertionOrderId}/targetingTypes/{targetingType}/assignedTargetingOptions',
    description=""" Assigns a targeting option to an insertion order. Returns the assigned targeting option if successful. Supported targeting types: * `TARGETING_TYPE_AGE_RANGE` * `TARGETING_TYPE_BROWSER` * `TARGETING_TYPE_CATEGORY` * `TARGETING_TYPE_CHANNEL` * `TARGETING_TYPE_DEVICE_MAKE_MODEL` * `TARGETING_TYPE_DIGITAL_CONTENT_LABEL_EXCLUSION` * `TARGETING_TYPE_ENVIRONMENT` * `TARGETING_TYPE_GENDER` * `TARGETING_TYPE_KEYWORD` * `TARGETING_TYPE_LANGUAGE` * `TARGETING_TYPE_NEGATIVE_KEYWORD_LIST` * `TARGETING_TYPE_OPERATING_SYSTEM` * `TARGETING_TYPE_PARENTAL_STATUS` * `TARGETING_TYPE_SENSITIVE_CATEGORY_EXCLUSION` * `TARGETING_TYPE_VIEWABILITY` """,
    tags=[
        'advertiser_management',
        'insertion_order_management',
        'targeting_options_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_assigned_targeting_option(
    advertiser_id: str = Path(..., alias='advertiserId'),
    insertion_order_id: str = Path(..., alias='insertionOrderId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AssignedTargetingOption = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}/insertionOrders/{insertionOrderId}/targetingTypes/{targetingType}/assignedTargetingOptions/{assignedTargetingOptionId}',
    description=""" Deletes an assigned targeting option from an insertion order. Supported targeting types: * `TARGETING_TYPE_AGE_RANGE` * `TARGETING_TYPE_BROWSER` * `TARGETING_TYPE_CATEGORY` * `TARGETING_TYPE_CHANNEL` * `TARGETING_TYPE_DEVICE_MAKE_MODEL` * `TARGETING_TYPE_DIGITAL_CONTENT_LABEL_EXCLUSION` * `TARGETING_TYPE_ENVIRONMENT` * `TARGETING_TYPE_GENDER` * `TARGETING_TYPE_KEYWORD` * `TARGETING_TYPE_LANGUAGE` * `TARGETING_TYPE_NEGATIVE_KEYWORD_LIST` * `TARGETING_TYPE_OPERATING_SYSTEM` * `TARGETING_TYPE_PARENTAL_STATUS` * `TARGETING_TYPE_SENSITIVE_CATEGORY_EXCLUSION` * `TARGETING_TYPE_VIEWABILITY` """,
    tags=[
        'advertiser_management',
        'insertion_order_management',
        'targeting_options_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_assigned_targeting_option_from_io(
    advertiser_id: str = Path(..., alias='advertiserId'),
    insertion_order_id: str = Path(..., alias='insertionOrderId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    assigned_targeting_option_id: str = Path(..., alias='assignedTargetingOptionId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/insertionOrders/{insertionOrderId}/targetingTypes/{targetingType}/assignedTargetingOptions/{assignedTargetingOptionId}',
    description=""" Gets a single targeting option assigned to an insertion order. """,
    tags=[
        'advertiser_management',
        'insertion_order_management',
        'targeting_options_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_assigned_targeting_options_for_insertion_order(
    advertiser_id: str = Path(..., alias='advertiserId'),
    insertion_order_id: str = Path(..., alias='insertionOrderId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    assigned_targeting_option_id: str = Path(..., alias='assignedTargetingOptionId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/insertionOrders/{insertionOrderId}:listAssignedTargetingOptions',
    description=""" Lists assigned targeting options of an insertion order across targeting types. """,
    tags=['insertion_order_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_advertiser_io_targeting_options(
    advertiser_id: str = Path(..., alias='advertiserId'),
    insertion_order_id: str = Path(..., alias='insertionOrderId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/invoices',
    description=""" Lists invoices posted for an advertiser in a given month. Invoices generated by billing profiles with a "Partner" invoice level are not retrievable through this method. """,
    tags=['advertiser_management', 'insertion_order_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_invoices_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    issue_month: Optional[str] = Query(None, alias='issueMonth'),
    loi_sapin_invoice_type: Optional[LoiSapinInvoiceType] = Query(
        None, alias='loiSapinInvoiceType'
    ),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/invoices:lookupInvoiceCurrency',
    description=""" Retrieves the invoice currency used by an advertiser in a given month. """,
    tags=['advertiser_management', 'insertion_order_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_invoices_lookup_invoice_currency(
    advertiser_id: str = Path(..., alias='advertiserId'),
    invoice_month: Optional[str] = Query(None, alias='invoiceMonth'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/lineItems',
    description=""" Lists line items in an advertiser. The order is defined by the order_by parameter. If a filter by entity_status is not specified, line items with `ENTITY_STATUS_ARCHIVED` will not be included in the results. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_line_items_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/lineItems',
    description=""" Creates a new line item. Returns the newly created line item if successful. """,
    tags=['advertiser_management', 'insertion_order_management', 'creative_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_line_items_create(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: LineItem = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}/lineItems/{lineItemId}',
    description=""" Deletes a line item. Returns error code `NOT_FOUND` if the line item does not exist. The line item should be archived first, i.e. set entity_status to `ENTITY_STATUS_ARCHIVED`, to be able to delete it. """,
    tags=['advertiser_management', 'insertion_order_management', 'bulk_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_line_items_delete(
    advertiser_id: str = Path(..., alias='advertiserId'),
    line_item_id: str = Path(..., alias='lineItemId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/lineItems/{lineItemId}',
    description=""" Gets a line item. """,
    tags=[
        'advertiser_management',
        'insertion_order_management',
        'campaign_management',
        'creative_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_line_items_get(
    advertiser_id: str = Path(..., alias='advertiserId'),
    line_item_id: str = Path(..., alias='lineItemId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/advertisers/{advertiserId}/lineItems/{lineItemId}',
    description=""" Updates an existing line item. Returns the updated line item if successful. Requests to this endpoint cannot be made concurrently with the following requests updating the same line item: * BulkEditAssignedTargetingOptions * BulkUpdateLineItems * CreateLineItemAssignedTargetingOption * DeleteLineItemAssignedTargetingOption """,
    tags=['advertiser_management', 'insertion_order_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_line_items_patch(
    advertiser_id: str = Path(..., alias='advertiserId'),
    line_item_id: str = Path(..., alias='lineItemId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: LineItem = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/lineItems/{lineItemId}/targetingTypes/{targetingType}/assignedTargetingOptions',
    description=""" Lists the targeting options assigned to a line item. """,
    tags=[
        'advertiser_management',
        'campaign_management',
        'targeting_options_management',
        'insertion_order_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_line_item_targeting_options_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    line_item_id: str = Path(..., alias='lineItemId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/lineItems/{lineItemId}/targetingTypes/{targetingType}/assignedTargetingOptions',
    description=""" Assigns a targeting option to a line item. Returns the assigned targeting option if successful. Requests to this endpoint cannot be made concurrently with the following requests updating the same line item: * BulkEditAssignedTargetingOptions * BulkUpdate * UpdateLineItem * DeleteLineItemAssignedTargetingOption """,
    tags=[
        'advertiser_management',
        'targeting_options_management',
        'campaign_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_targeting_option_for_line_item(
    advertiser_id: str = Path(..., alias='advertiserId'),
    line_item_id: str = Path(..., alias='lineItemId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AssignedTargetingOption = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}/lineItems/{lineItemId}/targetingTypes/{targetingType}/assignedTargetingOptions/{assignedTargetingOptionId}',
    description=""" Deletes an assigned targeting option from a line item. Requests to this endpoint cannot be made concurrently with the following requests updating the same line item: * BulkEditAssignedTargetingOptions * BulkUpdate * UpdateLineItem * CreateLineItemAssignedTargetingOption """,
    tags=[
        'advertiser_management',
        'targeting_options_management',
        'insertion_order_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_assigned_targeting_option(
    advertiser_id: str = Path(..., alias='advertiserId'),
    line_item_id: str = Path(..., alias='lineItemId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    assigned_targeting_option_id: str = Path(..., alias='assignedTargetingOptionId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/lineItems/{lineItemId}/targetingTypes/{targetingType}/assignedTargetingOptions/{assignedTargetingOptionId}',
    description=""" Gets a single targeting option assigned to a line item. """,
    tags=[
        'advertiser_management',
        'targeting_options_management',
        'campaign_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_assigned_targeting_options_for_line_item(
    advertiser_id: str = Path(..., alias='advertiserId'),
    line_item_id: str = Path(..., alias='lineItemId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    assigned_targeting_option_id: str = Path(..., alias='assignedTargetingOptionId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/lineItems/{lineItemId}:duplicate',
    description=""" Duplicates a line item. Returns the ID of the created line item if successful. """,
    tags=['advertiser_management', 'insertion_order_management', 'bulk_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_line_items_duplicate(
    advertiser_id: str = Path(..., alias='advertiserId'),
    line_item_id: str = Path(..., alias='lineItemId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: DuplicateLineItemRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/lineItems:bulkEditAssignedTargetingOptions',
    description=""" Bulk edits targeting options under multiple line items. The operation will delete the assigned targeting options provided in BulkEditAssignedTargetingOptionsRequest.delete_requests and then create the assigned targeting options provided in BulkEditAssignedTargetingOptionsRequest.create_requests. Requests to this endpoint cannot be made concurrently with the following requests updating the same line item: * BulkUpdate * UpdateLineItem * CreateLineItemAssignedTargetingOption * DeleteLineItemAssignedTargetingOption """,
    tags=['advertiser_management', 'bulk_operations', 'targeting_options_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bulk_edit_targeting_options_for_advertiser(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: BulkEditAssignedTargetingOptionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/lineItems:bulkListAssignedTargetingOptions',
    description=""" Lists assigned targeting options for multiple line items across targeting types. """,
    tags=['advertiser_management', 'campaign_management', 'insertion_order_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def fetch_advertiser_line_items_targeting_options(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    line_item_ids: Optional[LineItemIds] = Query(None, alias='lineItemIds'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/lineItems:bulkUpdate',
    description=""" Updates multiple line items. Requests to this endpoint cannot be made concurrently with the following requests updating the same line item: * BulkEditAssignedTargetingOptions * UpdateLineItem * CreateLineItemAssignedTargetingOption * DeleteLineItemAssignedTargetingOption """,
    tags=['advertiser_management', 'bulk_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_line_items_bulk_update(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: BulkUpdateLineItemsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/lineItems:generateDefault',
    description=""" Creates a new line item with settings (including targeting) inherited from the insertion order and an `ENTITY_STATUS_DRAFT` entity_status. Returns the newly created line item if successful. There are default values based on the three fields: * The insertion order's insertion_order_type * The insertion order's automation_type * The given line_item_type """,
    tags=['advertiser_management', 'insertion_order_management', 'bulk_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_line_items_generate_default(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: GenerateDefaultLineItemRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/locationLists',
    description=""" Lists location lists based on a given advertiser id. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_location_lists_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/locationLists',
    description=""" Creates a new location list. Returns the newly created location list if successful. """,
    tags=['advertiser_management', 'advertiser_location_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_location_lists_create(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: LocationList = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/advertisers/{advertiserId}/locationLists/{locationListId}',
    description=""" Updates a location list. Returns the updated location list if successful. """,
    tags=['advertiser_management', 'advertiser_location_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_location_lists_patch(
    advertiser_id: str = Path(..., alias='advertiserId'),
    location_list_id: str = Path(..., alias='locationListId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: LocationList = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/locationLists/{locationListId}/assignedLocations',
    description=""" Lists locations assigned to a location list. """,
    tags=['advertiser_management', 'advertiser_location_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_location_lists_assigned_locations_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    location_list_id: str = Path(..., alias='locationListId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/locationLists/{locationListId}/assignedLocations',
    description=""" Creates an assignment between a location and a location list. """,
    tags=['advertiser_management', 'advertiser_location_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_assigned_locations_for_advertiser_and_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    location_list_id: str = Path(..., alias='locationListId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AssignedLocation = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}/locationLists/{locationListId}/assignedLocations/{assignedLocationId}',
    description=""" Deletes the assignment between a location and a location list. """,
    tags=['advertiser_location_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_assigned_location_from_advertiser_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    location_list_id: str = Path(..., alias='locationListId'),
    assigned_location_id: str = Path(..., alias='assignedLocationId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/locationLists/{locationListId}/assignedLocations:bulkEdit',
    description=""" Bulk edits multiple assignments between locations and a single location list. The operation will delete the assigned locations provided in BulkEditAssignedLocationsRequest.deleted_assigned_locations and then create the assigned locations provided in BulkEditAssignedLocationsRequest.created_assigned_locations. """,
    tags=['advertiser_management', 'advertiser_location_management', 'bulk_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def edit_assigned_locations_for_advertiser_and_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    location_list_id: str = Path(..., alias='locationListId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: BulkEditAssignedLocationsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/manualTriggers',
    description=""" Lists manual triggers that are accessible to the current user for a given advertiser ID. The order is defined by the order_by parameter. A single advertiser_id is required. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_manual_triggers_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/manualTriggers',
    description=""" Creates a new manual trigger. Returns the newly created manual trigger if successful. """,
    tags=['advertiser_management', 'advertiser_manual_triggers_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_manual_triggers_create(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ManualTrigger = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/manualTriggers/{triggerId}',
    description=""" Gets a manual trigger. """,
    tags=['advertiser_management', 'advertiser_manual_triggers_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_manual_triggers_get(
    advertiser_id: str = Path(..., alias='advertiserId'),
    trigger_id: str = Path(..., alias='triggerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/advertisers/{advertiserId}/manualTriggers/{triggerId}',
    description=""" Updates a manual trigger. Returns the updated manual trigger if successful. """,
    tags=['advertiser_manual_triggers_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_manual_triggers_patch(
    advertiser_id: str = Path(..., alias='advertiserId'),
    trigger_id: str = Path(..., alias='triggerId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ManualTrigger = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/manualTriggers/{triggerId}:activate',
    description=""" Activates a manual trigger. Each activation of the manual trigger must be at least 5 minutes apart, otherwise an error will be returned. """,
    tags=['advertiser_manual_triggers_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_manual_triggers_activate(
    advertiser_id: str = Path(..., alias='advertiserId'),
    trigger_id: str = Path(..., alias='triggerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ActivateManualTriggerRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/manualTriggers/{triggerId}:deactivate',
    description=""" Deactivates a manual trigger. """,
    tags=['advertiser_manual_triggers_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_manual_triggers_deactivate(
    advertiser_id: str = Path(..., alias='advertiserId'),
    trigger_id: str = Path(..., alias='triggerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: DeactivateManualTriggerRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/negativeKeywordLists',
    description=""" Lists negative keyword lists based on a given advertiser id. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_negative_keyword_lists_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/negativeKeywordLists',
    description=""" Creates a new negative keyword list. Returns the newly created negative keyword list if successful. """,
    tags=['advertiser_management', 'negative_keyword_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_negative_keyword_lists_create(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: NegativeKeywordList = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/advertisers/{advertiserId}/negativeKeywordLists/{negativeKeywordListId}',
    description=""" Updates a negative keyword list. Returns the updated negative keyword list if successful. """,
    tags=['advertiser_management', 'negative_keyword_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_negative_keyword_lists_patch(
    advertiser_id: str = Path(..., alias='advertiserId'),
    negative_keyword_list_id: str = Path(..., alias='negativeKeywordListId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: NegativeKeywordList = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/negativeKeywordLists/{negativeKeywordListId}/negativeKeywords',
    description=""" Lists negative keywords in a negative keyword list. """,
    tags=['advertiser_management', 'negative_keyword_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_negative_keywords_for_advertiser(
    advertiser_id: str = Path(..., alias='advertiserId'),
    negative_keyword_list_id: str = Path(..., alias='negativeKeywordListId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}/negativeKeywordLists/{negativeKeywordListId}/negativeKeywords/{keywordValue}',
    description=""" Deletes a negative keyword from a negative keyword list. """,
    tags=['advertiser_management', 'negative_keyword_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_negative_keyword_from_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    negative_keyword_list_id: str = Path(..., alias='negativeKeywordListId'),
    keyword_value: str = Path(..., alias='keywordValue'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/negativeKeywordLists/{negativeKeywordListId}/negativeKeywords:bulkEdit',
    description=""" Bulk edits negative keywords in a single negative keyword list. The operation will delete the negative keywords provided in BulkEditNegativeKeywordsRequest.deleted_negative_keywords and then create the negative keywords provided in BulkEditNegativeKeywordsRequest.created_negative_keywords. This operation is guaranteed to be atomic and will never result in a partial success or partial failure. """,
    tags=['advertiser_management', 'negative_keyword_management', 'bulk_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bulk_edit_negative_keywords_for_advertiser(
    advertiser_id: str = Path(..., alias='advertiserId'),
    negative_keyword_list_id: str = Path(..., alias='negativeKeywordListId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: BulkEditNegativeKeywordsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/negativeKeywordLists/{negativeKeywordListId}/negativeKeywords:replace',
    description=""" Replaces all negative keywords in a single negative keyword list. The operation will replace the keywords in a negative keyword list with keywords provided in ReplaceNegativeKeywordsRequest.new_negative_keywords. """,
    tags=['negative_keyword_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def replace_negative_keywords_for_advertiser(
    advertiser_id: str = Path(..., alias='advertiserId'),
    negative_keyword_list_id: str = Path(..., alias='negativeKeywordListId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ReplaceNegativeKeywordsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/targetingTypes/{targetingType}/assignedTargetingOptions',
    description=""" Lists the targeting options assigned to an advertiser. """,
    tags=['advertiser_management', 'targeting_options_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_advertiser_targeting_options(
    advertiser_id: str = Path(..., alias='advertiserId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}/targetingTypes/{targetingType}/assignedTargetingOptions',
    description=""" Assigns a targeting option to an advertiser. Returns the assigned targeting option if successful. """,
    tags=['advertiser_management', 'targeting_options_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_targeting_option_for_advertiser(
    advertiser_id: str = Path(..., alias='advertiserId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AssignedTargetingOption = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/advertisers/{advertiserId}/targetingTypes/{targetingType}/assignedTargetingOptions/{assignedTargetingOptionId}',
    description=""" Deletes an assigned targeting option from an advertiser. """,
    tags=['advertiser_management', 'targeting_options_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_assigned_targeting_option_for_advertiser(
    advertiser_id: str = Path(..., alias='advertiserId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    assigned_targeting_option_id: str = Path(..., alias='assignedTargetingOptionId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/targetingTypes/{targetingType}/assignedTargetingOptions/{assignedTargetingOptionId}',
    description=""" Gets a single targeting option assigned to an advertiser. """,
    tags=['advertiser_management', 'targeting_options_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_assigned_targeting_options_for_advertiser(
    advertiser_id: str = Path(..., alias='advertiserId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    assigned_targeting_option_id: str = Path(..., alias='assignedTargetingOptionId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/youtubeAdGroupAds',
    description=""" Lists YouTube ad group ads. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_youtube_ad_group_ads_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/youtubeAdGroupAds/{youtubeAdGroupAdId}',
    description=""" Gets a YouTube ad group ad. """,
    tags=['advertiser_management', 'youtube_ad_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_youtube_ad_group_ads_get(
    advertiser_id: str = Path(..., alias='advertiserId'),
    youtube_ad_group_ad_id: str = Path(..., alias='youtubeAdGroupAdId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/youtubeAdGroups',
    description=""" Lists YouTube ad groups. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_youtube_ad_groups_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/youtubeAdGroups/{youtubeAdGroupId}',
    description=""" Gets a YouTube ad group. """,
    tags=['advertiser_management', 'youtube_ad_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_youtube_ad_groups_get(
    advertiser_id: str = Path(..., alias='advertiserId'),
    youtube_ad_group_id: str = Path(..., alias='youtubeAdGroupId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/youtubeAdGroups/{youtubeAdGroupId}/targetingTypes/{targetingType}/assignedTargetingOptions',
    description=""" Lists the targeting options assigned to a YouTube ad group. Inherited assigned targeting options are not included. """,
    tags=[
        'advertiser_management',
        'youtube_ad_group_management',
        'targeting_options_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_youtube_ad_group_targeting_options_list(
    advertiser_id: str = Path(..., alias='advertiserId'),
    youtube_ad_group_id: str = Path(..., alias='youtubeAdGroupId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/youtubeAdGroups/{youtubeAdGroupId}/targetingTypes/{targetingType}/assignedTargetingOptions/{assignedTargetingOptionId}',
    description=""" Gets a single targeting option assigned to a YouTube ad group. Inherited assigned targeting options are not included. """,
    tags=[
        'advertiser_management',
        'youtube_ad_group_management',
        'targeting_options_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_youtube_ad_group_targeting_options(
    advertiser_id: str = Path(..., alias='advertiserId'),
    youtube_ad_group_id: str = Path(..., alias='youtubeAdGroupId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    assigned_targeting_option_id: str = Path(..., alias='assignedTargetingOptionId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}/youtubeAdGroups:bulkListAdGroupAssignedTargetingOptions',
    description=""" Lists assigned targeting options for multiple YouTube ad groups across targeting types. Inherieted assigned targeting options are not included. """,
    tags=['advertiser_management', 'youtube_ad_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_youtube_ad_group_targeting_options(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    youtube_ad_group_ids: Optional[YoutubeAdGroupIds] = Query(
        None, alias='youtubeAdGroupIds'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}:audit',
    description=""" Audits an advertiser. Returns the counts of used entities per resource type under the advertiser provided. Used entities count towards their respective resource limit. See https://support.google.com/displayvideo/answer/6071450. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_audit(
    advertiser_id: str = Path(..., alias='advertiserId'),
    read_mask: Optional[str] = Query(None, alias='readMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/advertisers/{advertiserId}:editAssignedTargetingOptions',
    description=""" Edits targeting options under a single advertiser. The operation will delete the assigned targeting options provided in BulkEditAdvertiserAssignedTargetingOptionsRequest.delete_requests and then create the assigned targeting options provided in BulkEditAdvertiserAssignedTargetingOptionsRequest.create_requests . """,
    tags=['advertiser_management', 'targeting_options_management', 'bulk_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_edit_assigned_targeting_options(
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: BulkEditAdvertiserAssignedTargetingOptionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/advertisers/{advertiserId}:listAssignedTargetingOptions',
    description=""" Lists assigned targeting options of an advertiser across targeting types. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_advertisers_list_assigned_targeting_options(
    advertiser_id: str = Path(..., alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/combinedAudiences',
    description=""" Lists combined audiences. The order is defined by the order_by parameter. """,
    tags=['advertiser_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_combined_audiences_list(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/combinedAudiences/{combinedAudienceId}',
    description=""" Gets a combined audience. """,
    tags=[
        'combined_audience_management',
        'advertiser_management',
        'partner_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_combined_audiences_get(
    combined_audience_id: str = Path(..., alias='combinedAudienceId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customBiddingAlgorithms',
    description=""" Lists custom bidding algorithms that are accessible to the current user and can be used in bidding stratgies. The order is defined by the order_by parameter. """,
    tags=['advertiser_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_custom_bidding_algorithms_list(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/customBiddingAlgorithms',
    description=""" Creates a new custom bidding algorithm. Returns the newly created custom bidding algorithm if successful. """,
    tags=['bidding_algorithm_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_custom_bidding_algorithms_create(
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CustomBiddingAlgorithm = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customBiddingAlgorithms/{customBiddingAlgorithmId}',
    description=""" Gets a custom bidding algorithm. """,
    tags=['bidding_algorithm_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_custom_bidding_algorithms_get(
    custom_bidding_algorithm_id: str = Path(..., alias='customBiddingAlgorithmId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/customBiddingAlgorithms/{customBiddingAlgorithmId}',
    description=""" Updates an existing custom bidding algorithm. Returns the updated custom bidding algorithm if successful. """,
    tags=['bidding_algorithm_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_custom_bidding_algorithms_patch(
    custom_bidding_algorithm_id: str = Path(..., alias='customBiddingAlgorithmId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CustomBiddingAlgorithm = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customBiddingAlgorithms/{customBiddingAlgorithmId}/scripts',
    description=""" Lists custom bidding scripts that belong to the given algorithm. The order is defined by the order_by parameter. """,
    tags=['bidding_algorithm_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_custom_bidding_algorithms_scripts_list(
    custom_bidding_algorithm_id: str = Path(..., alias='customBiddingAlgorithmId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/customBiddingAlgorithms/{customBiddingAlgorithmId}/scripts',
    description=""" Creates a new custom bidding script. Returns the newly created script if successful. """,
    tags=['bidding_algorithm_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_custom_bidding_algorithms_scripts_create(
    custom_bidding_algorithm_id: str = Path(..., alias='customBiddingAlgorithmId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CustomBiddingScript = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customBiddingAlgorithms/{customBiddingAlgorithmId}/scripts/{customBiddingScriptId}',
    description=""" Gets a custom bidding script. """,
    tags=['bidding_algorithm_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_custom_bidding_algorithms_scripts_get(
    custom_bidding_algorithm_id: str = Path(..., alias='customBiddingAlgorithmId'),
    custom_bidding_script_id: str = Path(..., alias='customBiddingScriptId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customBiddingAlgorithms/{customBiddingAlgorithmId}:uploadScript',
    description=""" Creates a custom bidding script reference object for a script file. The resulting reference object provides a resource path to which the script file should be uploaded. This reference object should be included in when creating a new custom bidding script object. """,
    tags=['bidding_algorithm_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_custom_bidding_algorithms_upload_script(
    custom_bidding_algorithm_id: str = Path(..., alias='customBiddingAlgorithmId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customLists',
    description=""" Lists custom lists. The order is defined by the order_by parameter. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_custom_lists_list(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customLists/{customListId}',
    description=""" Gets a custom list. """,
    tags=['custom_lists_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_custom_lists_get(
    custom_list_id: str = Path(..., alias='customListId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/firstAndThirdPartyAudiences',
    description=""" Lists first and third party audiences. The order is defined by the order_by parameter. """,
    tags=['advertiser_management', 'campaign_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_first_and_third_party_audiences_list(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/firstAndThirdPartyAudiences',
    description=""" Creates a FirstAndThirdPartyAudience. Only supported for the following audience_type: * `CUSTOMER_MATCH_CONTACT_INFO` * `CUSTOMER_MATCH_DEVICE_ID` """,
    tags=['advertiser_management', 'audience_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_first_and_third_party_audiences_create(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: FirstAndThirdPartyAudience = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/firstAndThirdPartyAudiences/{firstAndThirdPartyAudienceId}',
    description=""" Gets a first and third party audience. """,
    tags=['audience_management', 'combined_audience_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_first_and_third_party_audiences_get(
    first_and_third_party_audience_id: str = Path(
        ..., alias='firstAndThirdPartyAudienceId'
    ),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/firstAndThirdPartyAudiences/{firstAndThirdPartyAudienceId}',
    description=""" Updates an existing FirstAndThirdPartyAudience. Only supported for the following audience_type: * `CUSTOMER_MATCH_CONTACT_INFO` * `CUSTOMER_MATCH_DEVICE_ID` """,
    tags=['audience_management', 'combined_audience_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_first_and_third_party_audiences_patch(
    first_and_third_party_audience_id: str = Path(
        ..., alias='firstAndThirdPartyAudienceId'
    ),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: FirstAndThirdPartyAudience = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/firstAndThirdPartyAudiences/{firstAndThirdPartyAudienceId}:editCustomerMatchMembers',
    description=""" Updates the member list of a Customer Match audience. Only supported for the following audience_type: * `CUSTOMER_MATCH_CONTACT_INFO` * `CUSTOMER_MATCH_DEVICE_ID` """,
    tags=['audience_management', 'combined_audience_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def edit_customer_match_members_for_audience(
    first_and_third_party_audience_id: str = Path(
        ..., alias='firstAndThirdPartyAudienceId'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: EditCustomerMatchMembersRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/floodlightGroups/{floodlightGroupId}',
    description=""" Gets a Floodlight group. """,
    tags=['floodlight_group_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_floodlight_groups_get(
    floodlight_group_id: str = Path(..., alias='floodlightGroupId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/googleAudiences',
    description=""" Lists Google audiences. The order is defined by the order_by parameter. """,
    tags=['advertiser_management', 'campaign_management', 'audience_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_google_audiences_list(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/googleAudiences/{googleAudienceId}',
    description=""" Gets a Google audience. """,
    tags=['audience_management', 'partner_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_google_audiences_get(
    google_audience_id: str = Path(..., alias='googleAudienceId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/guaranteedOrders',
    description=""" Lists guaranteed orders that are accessible to the current user. The order is defined by the order_by parameter. If a filter by entity_status is not specified, guaranteed orders with entity status `ENTITY_STATUS_ARCHIVED` will not be included in the results. """,
    tags=['advertiser_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_guaranteed_orders_list(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/guaranteedOrders',
    description=""" Creates a new guaranteed order. Returns the newly created guaranteed order if successful. """,
    tags=['advertiser_management', 'guaranteed_order_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_guaranteed_orders_create(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: GuaranteedOrder = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/guaranteedOrders/{guaranteedOrderId}',
    description=""" Gets a guaranteed order. """,
    tags=['guaranteed_order_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_guaranteed_orders_get(
    guaranteed_order_id: str = Path(..., alias='guaranteedOrderId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/guaranteedOrders/{guaranteedOrderId}',
    description=""" Updates an existing guaranteed order. Returns the updated guaranteed order if successful. """,
    tags=['guaranteed_order_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_guaranteed_orders_patch(
    guaranteed_order_id: str = Path(..., alias='guaranteedOrderId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: GuaranteedOrder = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/guaranteedOrders/{guaranteedOrderId}:editGuaranteedOrderReadAccessors',
    description=""" Edits read advertisers of a guaranteed order. """,
    tags=['guaranteed_order_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def edit_guaranteed_order_accessors(
    guaranteed_order_id: str = Path(..., alias='guaranteedOrderId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: EditGuaranteedOrderReadAccessorsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/inventorySourceGroups',
    description=""" Lists inventory source groups that are accessible to the current user. The order is defined by the order_by parameter. """,
    tags=['advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_inventory_source_groups_list(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/inventorySourceGroups',
    description=""" Creates a new inventory source group. Returns the newly created inventory source group if successful. """,
    tags=[
        'advertiser_management',
        'inventory_source_group_management',
        'partner_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_inventory_source_groups_create(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: InventorySourceGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/inventorySourceGroups/{inventorySourceGroupId}',
    description=""" Deletes an inventory source group. """,
    tags=['inventory_source_group_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_inventory_source_groups_delete(
    inventory_source_group_id: str = Path(..., alias='inventorySourceGroupId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/inventorySourceGroups/{inventorySourceGroupId}',
    description=""" Gets an inventory source group. """,
    tags=['inventory_source_group_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_inventory_source_groups_get(
    inventory_source_group_id: str = Path(..., alias='inventorySourceGroupId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/inventorySourceGroups/{inventorySourceGroupId}/assignedInventorySources',
    description=""" Lists inventory sources assigned to an inventory source group. """,
    tags=[
        'inventory_source_group_management',
        'inventory_source_management',
        'partner_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_inventory_sources_by_group_id(
    inventory_source_group_id: str = Path(..., alias='inventorySourceGroupId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/inventorySourceGroups/{inventorySourceGroupId}/assignedInventorySources',
    description=""" Creates an assignment between an inventory source and an inventory source group. """,
    tags=['inventory_source_group_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_assigned_inventory_source_for_group(
    inventory_source_group_id: str = Path(..., alias='inventorySourceGroupId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AssignedInventorySource = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/inventorySourceGroups/{inventorySourceGroupId}/assignedInventorySources/{assignedInventorySourceId}',
    description=""" Deletes the assignment between an inventory source and an inventory source group. """,
    tags=[
        'inventory_source_group_management',
        'advertiser_management',
        'partner_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_assigned_inventory_source_from_group(
    inventory_source_group_id: str = Path(..., alias='inventorySourceGroupId'),
    assigned_inventory_source_id: str = Path(..., alias='assignedInventorySourceId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/inventorySourceGroups/{inventorySourceGroupId}/assignedInventorySources:bulkEdit',
    description=""" Bulk edits multiple assignments between inventory sources and a single inventory source group. The operation will delete the assigned inventory sources provided in BulkEditAssignedInventorySourcesRequest.deleted_assigned_inventory_sources and then create the assigned inventory sources provided in BulkEditAssignedInventorySourcesRequest.created_assigned_inventory_sources. """,
    tags=[
        'inventory_source_group_management',
        'inventory_source_management',
        'bulk_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bulk_edit_inventory_sources_for_group(
    inventory_source_group_id: str = Path(..., alias='inventorySourceGroupId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: BulkEditAssignedInventorySourcesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/inventorySources',
    description=""" Lists inventory sources that are accessible to the current user. The order is defined by the order_by parameter. If a filter by entity_status is not specified, inventory sources with entity status `ENTITY_STATUS_ARCHIVED` will not be included in the results. """,
    tags=['advertiser_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_inventory_sources_list(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/inventorySources',
    description=""" Creates a new inventory source. Returns the newly created inventory source if successful. """,
    tags=['advertiser_management', 'inventory_source_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_inventory_sources_create(
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: InventorySource = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/inventorySources/{inventorySourceId}',
    description=""" Gets an inventory source. """,
    tags=['inventory_source_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_inventory_sources_get(
    inventory_source_id: str = Path(..., alias='inventorySourceId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/inventorySources/{inventorySourceId}',
    description=""" Updates an existing inventory source. Returns the updated inventory source if successful. """,
    tags=['inventory_source_management', 'advertiser_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_inventory_sources_patch(
    inventory_source_id: str = Path(..., alias='inventorySourceId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    partner_id: Optional[str] = Query(None, alias='partnerId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: InventorySource = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/inventorySources/{inventorySourceId}:editInventorySourceReadWriteAccessors',
    description=""" Edits read/write accessors of an inventory source. Returns the updated read_write_accessors for the inventory source. """,
    tags=['inventory_source_management', 'inventory_source_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def edit_inventory_source_accessors(
    inventory_source_id: str = Path(..., alias='inventorySourceId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: EditInventorySourceReadWriteAccessorsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/partners',
    description=""" Lists partners that are accessible to the current user. The order is defined by the order_by parameter. """,
    tags=[
        'advertiser_management',
        'campaign_management',
        'creative_management',
        'audience_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_partners_list(
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/partners/{partnerId}',
    description=""" Gets a partner. """,
    tags=['partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_partners_get(
    partner_id: str = Path(..., alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/partners/{partnerId}/channels',
    description=""" Lists channels for a partner or advertiser. """,
    tags=['advertiser_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_partners_channels_list(
    partner_id: str = Path(..., alias='partnerId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/partners/{partnerId}/channels',
    description=""" Creates a new channel. Returns the newly created channel if successful. """,
    tags=['channel_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_partners_channels_create(
    partner_id: str = Path(..., alias='partnerId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/partners/{partnerId}/channels/{channelId}',
    description=""" Updates a channel. Returns the updated channel if successful. """,
    tags=['channel_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_partners_channels_patch(
    partner_id: str = Path(..., alias='partnerId'),
    channel_id: str = Path(..., alias='channelId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/partners/{partnerId}/channels/{channelId}/sites',
    description=""" Lists sites in a channel. """,
    tags=['advertiser_management', 'channel_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_partners_channels_sites_list(
    partner_id: str = Path(..., alias='partnerId'),
    channel_id: str = Path(..., alias='channelId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/partners/{partnerId}/channels/{channelId}/sites/{urlOrAppId}',
    description=""" Deletes a site from a channel. """,
    tags=[
        'advertiser_management',
        'campaign_management',
        'channel_management',
        'creative_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_partners_channels_sites_delete(
    partner_id: str = Path(..., alias='partnerId'),
    channel_id: str = Path(..., alias='channelId'),
    url_or_app_id: str = Path(..., alias='urlOrAppId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/partners/{partnerId}/channels/{channelId}/sites:bulkEdit',
    description=""" Bulk edits sites under a single channel. The operation will delete the sites provided in BulkEditSitesRequest.deleted_sites and then create the sites provided in BulkEditSitesRequest.created_sites. """,
    tags=['bulk_operations', 'channel_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_partners_channels_sites_bulk_edit(
    partner_id: str = Path(..., alias='partnerId'),
    channel_id: str = Path(..., alias='channelId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: BulkEditSitesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/partners/{partnerId}/channels/{channelId}/sites:replace',
    description=""" Replaces all of the sites under a single channel. The operation will replace the sites under a channel with the sites provided in ReplaceSitesRequest.new_sites. """,
    tags=['channel_management', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_partners_channels_sites_replace(
    partner_id: str = Path(..., alias='partnerId'),
    channel_id: str = Path(..., alias='channelId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ReplaceSitesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/partners/{partnerId}/targetingTypes/{targetingType}/assignedTargetingOptions',
    description=""" Lists the targeting options assigned to a partner. """,
    tags=[
        'advertiser_management',
        'targeting_options_management',
        'campaign_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def retrieve_partner_targeting_options_list(
    partner_id: str = Path(..., alias='partnerId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/partners/{partnerId}/targetingTypes/{targetingType}/assignedTargetingOptions',
    description=""" Assigns a targeting option to a partner. Returns the assigned targeting option if successful. """,
    tags=['targeting_options_management', 'campaign_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_assigned_targeting_option_for_partner(
    partner_id: str = Path(..., alias='partnerId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AssignedTargetingOption = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/partners/{partnerId}/targetingTypes/{targetingType}/assignedTargetingOptions/{assignedTargetingOptionId}',
    description=""" Deletes an assigned targeting option from a partner. """,
    tags=[
        'targeting_options_management',
        'campaign_management',
        'advertiser_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_partner_targeting_option(
    partner_id: str = Path(..., alias='partnerId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    assigned_targeting_option_id: str = Path(..., alias='assignedTargetingOptionId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/partners/{partnerId}/targetingTypes/{targetingType}/assignedTargetingOptions/{assignedTargetingOptionId}',
    description=""" Gets a single targeting option assigned to a partner. """,
    tags=[
        'targeting_options_management',
        'campaign_management',
        'advertiser_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_partners_targeting_options_details(
    partner_id: str = Path(..., alias='partnerId'),
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    assigned_targeting_option_id: str = Path(..., alias='assignedTargetingOptionId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/partners/{partnerId}:editAssignedTargetingOptions',
    description=""" Edits targeting options under a single partner. The operation will delete the assigned targeting options provided in BulkEditPartnerAssignedTargetingOptionsRequest.deleteRequests and then create the assigned targeting options provided in BulkEditPartnerAssignedTargetingOptionsRequest.createRequests . """,
    tags=['targeting_options_management', 'bulk_operations', 'partner_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_partners_edit_assigned_targeting_options(
    partner_id: str = Path(..., alias='partnerId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: BulkEditPartnerAssignedTargetingOptionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/sdfdownloadtasks',
    description=""" Creates an SDF Download Task. Returns an Operation. An SDF Download Task is a long-running, asynchronous operation. The metadata type of this operation is SdfDownloadTaskMetadata. If the request is successful, the response type of the operation is SdfDownloadTask. The response will not include the download files, which must be retrieved with media.download. The state of operation can be retrieved with sdfdownloadtask.operations.get. Any errors can be found in the error.message. Note that error.details is expected to be empty. """,
    tags=['media_operations', 'video_download_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_sdfdownloadtasks_create(
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CreateSdfDownloadTaskRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/targetingTypes/{targetingType}/targetingOptions',
    description=""" Lists targeting options of a given type. """,
    tags=[
        'advertiser_management',
        'targeting_options_management',
        'campaign_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_targeting_types_targeting_options_list(
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/targetingTypes/{targetingType}/targetingOptions/{targetingOptionId}',
    description=""" Gets a single targeting option. """,
    tags=['targeting_options_management', 'advertiser_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_targeting_types_targeting_options_get(
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    targeting_option_id: str = Path(..., alias='targetingOptionId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/targetingTypes/{targetingType}/targetingOptions:search',
    description=""" Searches for targeting options of a given type based on the given search terms. """,
    tags=['targeting_options_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_targeting_types_targeting_options_search(
    targeting_type: TargetingType = Path(..., alias='targetingType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: SearchTargetingOptionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/users',
    description=""" Lists users that are accessible to the current user. If two users have user roles on the same partner or advertiser, they can access each other. """,
    tags=[
        'advertiser_management',
        'campaign_management',
        'creative_management',
        'audience_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_users_list(
    filter: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/users',
    description=""" Creates a new user. Returns the newly created user if successful. """,
    tags=['user_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_users_create(
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: User = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/users/{userId}',
    description=""" Deletes a user. """,
    tags=['user_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_users_delete(
    user_id: str = Path(..., alias='userId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/users/{userId}',
    description=""" Gets a user. """,
    tags=['user_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_users_get(
    user_id: str = Path(..., alias='userId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/users/{userId}',
    description=""" Updates an existing user. Returns the updated user if successful. """,
    tags=['user_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_users_patch(
    user_id: str = Path(..., alias='userId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: User = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/users/{userId}:bulkEditAssignedUserRoles',
    description=""" Bulk edits user roles for a user. The operation will delete the assigned user roles provided in BulkEditAssignedUserRolesRequest.deletedAssignedUserRoles and then assign the user roles provided in BulkEditAssignedUserRolesRequest.createdAssignedUserRoles. """,
    tags=['user_management', 'bulk_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_users_bulk_edit_assigned_user_roles(
    user_id: str = Path(..., alias='userId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: BulkEditAssignedUserRolesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/{name}',
    description=""" Gets the latest state of an asynchronous SDF download task operation. Clients should poll this method at intervals of 30 seconds. """,
    tags=['media_operations', 'advertiser_management', 'campaign_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def displayvideo_sdfdownloadtasks_operations_get(
    name: str,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
